# 9020번 골드바흐의 추측
[문제 보러가기](https://www.acmicpc.net/problem/9020)

## 🅰 설계
소수 찾기 알고리즘(에라토스테네스의 체) + 완전탐색문제입니다.

### 소수찾기 알고리즘
입력으로 주어진 n이 소수인지 판단하는 가장 기본적인 알고리즘입니다.

```java 
for(int i=2; i<n; i++) {
    if(n % i == 0) return false;
}
returnt true;    
```

이는 시간복잡도 O(n)의 알고리즘으로 만약 `1부터 N까지 모든 소수`를 다 찾아야 한다면
O(N<sup>2</sup>)의 시간이 걸립니다. 1초내에 계산할 수 있는 한계 N은 약 `1만`정도입니다.
이 알고리즘은 좀 더 최적화 할 수 있는 방법이 있습니다.
1. 모든 합성수 n은 sqrt(n) 이하의 소인수를 가집니다. 따라서 for문을 `sqrt(n)`까지만
돌려도 충분합니다. 이 경우 시간복잡도는 `O(n * sqrt(n))`으로 1초내에 계산 가능한
   한계 N은 약 `10만`입니다.
   
2. 이미 이전에 합성수로 판단된 n에 대해서는 다시 체크할 필요가 없습니다. 따라서
소수인지 아닌지를 저장해놓는 배열을 하나 만들어서 활용한다면 시간을 더 단축시킬 수
   있습니다.
   
```java 
void eratosthenes() {
    int sqrtn = (int)Math.sqrt(n);
    for(int i=2; i<=sqrtn; i++) {
        // 만약 i가 소수라면
        if(isPrime[i]) {
            // i의 배수들은 전부 합성수로 변경
            for(int j=i*i; j<=n; j+=i)
                isPrime[j] = false;
        }
    }
}    
```

외부 for문의 범위를 `i <= sqrt(n)` 으로 설정한 것 이외에도 내부 for문에서도 약간의
최적화가 들어갑니다. `i*i` 보다 작은 합성수는 이미 이 이전에 필터링이 되기 때문에
j는 `i*i`에서부터 시작합니다. 이 알고리즘의 시간복잡도는 소수의 빈도에 관한 소수 정리를
써야하기 때문에 몹시 고등수학이 필요하지만 `O(n * log(log(n)))`임이 알려져 있습니다.
이는 거의 `O(n)`과 동일한 시간복잡도로 1초내에 계산할 수 있는 한계 N은 약 `2천만`
정도입니다.

합이 짝수 n이 되는 소수를 찾는 부분에서는 소수만을 담은 리스트를 사용할지 `boolean`배열을
사용할지 고민했습니다. 초기 풀이엔 소수 리스트를 사용해서 이중 for문을 돌렸는데 제 생각보다 
소수의 빈도가 높아서(`만 이하 소수의 개수 = 1229개`) 소수만을 필터링한다고 해서 시간이 크게 단축되지도 않을 뿐더러 이중 for문으로 인해
시간이 꽤 걸렸습니다. 그에 비해 `boolean`배열을 그대로 사용하면 투포인터로 `O(n)`에 해결할
방법이 있었기 때문에 소수 리스트를 활용한 방법보다 훨씬 빨랐습니다.

```java 
for(int i = target/2; i>=0; i--) {
    if(isPrime[i] & isPrime[target-i]) {
        sb.append(i).append(" ").append(target-i).append("\n");
        break;
    }
}
```

## ✅ 후기
안그래도 요즘 투포인터 알고리즘을 공부하면서 문제를 이것저것 풀어보고 있었는데 정작
이 문제에서는 놓쳐서 아쉽습니다.