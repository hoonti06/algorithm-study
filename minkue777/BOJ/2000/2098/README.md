# 2098번 외판원 순회
[문제 보러가기](https://www.acmicpc.net/problem/2098)

## 🅰 설계
완전탐색을 배울 때 항상 다루는 TSP 문제입니다. 완전탐색 문제로 주어질 경우 N이
10이하로 주어지는 경우가 많은데 이번 문제 조건에서는 N이 16이므로 완전탐색을 할 수
없습니다. `16! ~ 1e13` TSP는 여러 선택지 중에서 가장 최적의 선택지를 골라야 하는
문제로 최적화 문제로 분류됩니다. 그리고 사실 동적계획법은 이런 최적화 문제를 빠르게
해결하기 위해 고안된 테크닉으로 동적계획법에 초석이 된 문제라고 볼수도 있습니다.

이 문제해결의 시작점은 반복되는 연산이 어디에 있는지 파악하는 것입니다. 그리고
**현재 위치와 지금까지 방문했던 도시가 주어진다면 그 이후의 최단거리가 결정된다**
라는 사실을 파악한다면 문제의 9할은 해결됩니다. 나머지 1할은 지금까지 방문했던 도시
를 어떤 형태로 저장할 것인가입니다. 만약 `boolean[]`을 사용한다면 DP 테이블을
해쉬맵으로 만들 수 밖에 없습니다. 이는 시간적으로도 공간적으로도 좋지 못한 방식입니다.
더 좋은 방법은 `boolean 배열을 하나의 정수로 바꾸어서 배열의 인덱스로 사용하는 것`
입니다. 그리고 boolean 배열을 정수와 일대일 대응시키는 가장 심플한 방법은
비트마스크를 사용하는 것입니다.
```java 
static int shortestPath(int cur, int visited) {
    // 기저 케이스 모든 도시를 다 방문했을 때는 처음 위치로 돌아감
    if(visited == (1 << n)-1) return dist[cur][0];
    // 이미 기존에 계산한 상황이면 그 값을 그대로 반환
    if(cache[cur][visited] != -1) return cache[cur][visited];
    int cost = INF;
    for(int next=1; next<n; next++) {
        // 아직 방문하지 않은 도시라면
        if((visited & (1 << next)) == 0)
            // 현재 비용과 그 도시를 방문했을 때 최소비용을 비교하여 비용을 갱신
            cost = Math.min(cost, dist[cur][next] +
                    shortestPath(next, visited + (1 << next)));
    }
    // 캐시에 값을 저장 후 반환
    return cache[cur][visited] = cost;
}
```

`shortestPath(cur, visited)` 메소드는 현재 위치와 지금까지 방문한 도시 내역을 인자로 받아서
남은 도시를 전부 방문하는 거리의 최소값을 반환해주는 함수입니다. 이전에 계산했던 결과라면
캐시에서 값을 받아서 리턴하고 그게 아니라면 재귀 호출을 통해 계산 후 캐시에 값을 저장합니다.
이때 캐시 배열의 크기는 16 * 2^16 인데 약 `104만`으로 대략 `10경`정도였던 `16!`과 비교하면
매우 적은숫자이고 시간제한 내에 해결할 수 있습니다.

## ✅ 후기
처음 비트마스크를 이용한 동적계획법 문제의 표본입니다. 사실 아이디어만 있다면
생각보다 쉽게 풀리는 문제이기 때문에 못푸셨더라도 꼭 다시 풀어보시길 추천합니다.