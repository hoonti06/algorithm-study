# 9020번 골드바흐의 추측
[문제 보러가기](https://www.acmicpc.net/problem/9020)

두개의 소수의 합이 입력 짝수가 나오는 소수의 쌍을 구하는 문제

## 🅰 설계
1. 전체 10000까지의 양수 중에서 소수만 따로 분리하여 새로운 배열을 만들었습니다.
2. 입력 짝수보다 바로 작은 소수를 값으로 가지는 인덱스를 시작 인덱스로 잡아주었습니다.
3. 시작 인덱스를 투 포인터 탐색을 하였습니다.

### 변수
```java
static boolean number[];	//전체 숫자중 소수를 체크할 배열
static int prime[], primeCnt;	//소수만 담는 배열, 소수의 개수를 카운트 할 변수
```

### 


### 소수 체크하기
```java
number = new boolean[10001];
for (int i = 2; i <= 10000; i++) {
    //현재 i가 소수이면, i의 배수는 합성수이다.
    if (number[i] == false) {
        primeCnt++;	//소수 배열 사이즈 카운트
        for (int j = 2; j * i <= 10000; j++) {
            number[i * j] = true;
        }
    }
}
```

### 시작 인덱스 잡아주기
```java
//시작 인덱스 잡아주기
for (int i = 0; i < primeCnt; i++) {
    //입력 정수 N의 반절보다 현재 소수가 크다면 바로 전 소수를 시작인덱스를 잡아주었다.
    //N=10일경우 N/2 는 5이고, 5보다 큰 소수는 7이고 바로 전의 소수는 5이기때문에
    if (prime[i] > N / 2) {
        front = i - 1;
        back = i - 1;
        break;
    }
}
```



### 두개의 인덱스를 이용하여 합 구하기

```java
// 소수의 합이 N일 때 까지 반복
while (prime[front] + prime[back] != N) {
    if (prime[front] + prime[back] > N) {
        front--;
    } else if (prime[front] + prime[back] < N) {
        back++;
    }
}
```



## ✅ 후기

#### 처음에는 조합을 이용하여, 2개가 충족되면 합을 검사하는 방식으로 하였습니다. 하지만 그리한다면, 시간초과가 뜨는것은 당연지사일 것이라고 생각하였고, 위의 접근법을 생각하기까지 꽤 시간을 소모하였습니다. 이렇듯, 접근방식에 따라 문제의 난이도가 좌우되는 것처럼 접근방식의 중요성을 다시 한 번 깨닫게 되었습니다.
